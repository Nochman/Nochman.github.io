<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>LLN Minimal Simulator</title>
  <style>
    body { margin: 0; font-family: Arial, sans-serif; background: #ffffff; color: #222; }
    header { padding: 12px 16px; border-bottom: 1px solid #ddd; }
    h1 { margin: 0; font-size: 18px; }
    .wrap { display: grid; grid-template-columns: 300px 860px; grid-template-rows: auto 500px; column-gap: 12px; row-gap: 12px; padding: 12px 16px; }
    .panel { border: 1px solid #ddd; padding: 10px; }
    .controls label { display: block; margin: 6px 0 2px; font-size: 12px; }
    .controls input { width: 100%; padding: 6px 8px; border: 1px solid #bbb; border-radius: 4px; font-size: 14px; }
    .controls button { margin-top: 8px; padding: 8px 10px; font-size: 14px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; column-gap: 8px; }
    .canwrap { display: grid; grid-template-columns: 560px 280px; column-gap: 12px; }
    canvas { background: #fafafa; border: 1px solid #ddd; }
    .note { font-size: 12px; color: #555; }
  </style>
</head>
<body>
  <header>
    <h1>Law of Large Numbers — Minimal Demo</h1>
  </header>

  <div class="wrap">
    <div class="panel controls">
      <div class="row">
        <div>
          <label for="p">Probability p (0–1)</label>
          <input id="p" type="number" step="0.01" min="0" max="1" value="0.6" />
        </div>
        <div>
          <label for="m">Trajectories m</label>
          <input id="m" type="number" min="5" max="500" step="5" value="100" />
        </div>
      </div>
      <div class="row">
        <div>
          <label for="n">Trials n</label>
          <input id="n" type="number" min="50" max="5000" step="50" value="1000" />
        </div>
        <div>
          <label for="k">Histogram index k</label>
          <input id="k" type="number" min="1" step="1" value="1000" />
        </div>
      </div>
      <div class="row">
        
        <div style="display:flex; align-items:flex-end;">
          <button id="run">Simulate</button>
        </div>
      </div>
      <p class="note">This shows m trajectories of the running relative frequency f(n) and a vertical histogram of f(k) across trajectories. The dashed red line is the true p.</p>
      <div id="stats" class="note"></div>
    </div>

    <div class="panel" style="grid-column: 2 / 3; grid-row: 1 / 3;">
      <div class="canwrap">
        <canvas id="traj" width="560" height="500"></canvas>
        <canvas id="hist" width="280" height="500"></canvas>
      </div>
    </div>
  </div>

  <script>
    // --- Minimal helpers ---
    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
    function mulberry32(a){ return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15, t|1); t^=t+Math.imul(t^t>>>7, t|61); return ((t^t>>>14)>>>0)/4294967296; } }
    function hashString(s){ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0; }

    // --- DOM ---
    const pEl = document.getElementById('p');
    const mEl = document.getElementById('m');
    const nEl = document.getElementById('n');
    const kEl = document.getElementById('k');
    const stats = document.getElementById('stats');
    const runBtn = document.getElementById('run');

    const traj = document.getElementById('traj');
    const hist = document.getElementById('hist');
    const tctx = traj.getContext('2d');
    const hctx = hist.getContext('2d');

    let F = null, m=0, n=0, p=0;

    function simulate(){
      p = clamp(parseFloat(pEl.value)||0, 0, 1);
      m = clamp(parseInt(mEl.value)||0, 5, 500);
      n = clamp(parseInt(nEl.value)||0, 50, 5000);
      const rng = Math.random;

      // Ensure k is in range
      if (!kEl.value) kEl.value = n; else kEl.value = clamp(parseInt(kEl.value)||n, 1, n);

      // Precompute cumulative frequencies per trajectory
      F = new Float32Array(m*n);
      for (let i=0;i<m;i++){
        let sum=0;
        for (let j=0;j<n;j++){
          if (rng() < p) sum += 1;
          F[i*n + j] = sum/(j+1);
        }
      }
      kEl.value = n;         
      draw();
      updateStats(parseInt(kEl.value));
    }

    function draw(){
      drawTrajectories(parseInt(kEl.value));
      drawHistogram(parseInt(kEl.value));
    }

    function drawTrajectories(k){
      const L=40, R=10, T=10, B=36; const cw=traj.width, ch=traj.height; const W=cw-L-R, H=ch-T-B;
      tctx.clearRect(0,0,cw,ch);
      // axes
      tctx.strokeStyle="#ccc"; tctx.lineWidth=1; tctx.beginPath();
      tctx.moveTo(L,ch-B); tctx.lineTo(cw-R,ch-B); tctx.moveTo(L,T); tctx.lineTo(L,ch-B); tctx.stroke();
      // grid
      tctx.fillStyle="#666"; tctx.font="10px Arial";
      for (let i=0;i<=5;i++){ const v=i/5, y=ch-B - v*H; tctx.strokeStyle="#eee"; tctx.beginPath(); tctx.moveTo(L,y); tctx.lineTo(cw-R,y); tctx.stroke(); tctx.fillText(v.toFixed(2), 6, y+3); }
      // true p
      const yp = ch-B - p*H; tctx.strokeStyle="#e74c3c"; tctx.setLineDash([6,6]); tctx.beginPath(); tctx.moveTo(L,yp); tctx.lineTo(cw-R,yp); tctx.stroke(); tctx.setLineDash([]);
      // vertical at k
      if (k){ const xk = L + (k-1)/(n-1)*W; tctx.strokeStyle="#8888ff"; tctx.beginPath(); tctx.moveTo(xk,T); tctx.lineTo(xk,ch-B); tctx.stroke(); }
      // trajectories
      tctx.strokeStyle="rgba(120,120,120,0.5)"; tctx.lineWidth=1;
      for (let i=0;i<m;i++){
        tctx.beginPath();
        for (let j=0;j<n;j++){
          const x = L + j/(n-1)*W; const y = ch-B - F[i*n + j]*H; if (j===0) tctx.moveTo(x,y); else tctx.lineTo(x,y);
        }
        tctx.stroke();
      }
      // labels
      tctx.fillStyle="#333"; tctx.font="12px Arial"; tctx.fillText("Number of trials (n)", L + W/2 - 60, ch-10);
      tctx.save(); tctx.translate(12, T + H/2 + 40); tctx.rotate(-Math.PI/2); tctx.fillText("Relative frequency f(n)", 0, 0); tctx.restore();
    }

    function drawHistogram(k){
  const dpi = window.devicePixelRatio || 1;
  const cw = hist.width, ch = hist.height;
  const L = 40, R = 20, T = 20, B = 40;
  const W = cw - L - R, H = ch - T - B;

  hctx.clearRect(0,0,cw,ch);

  // gather f(k) across trajectories
  const vals = new Float32Array(m);
  for(let i=0;i<m;i++) vals[i] = F[i*n + (k-1)];

  // binning
  const bins = Math.min(26, Math.ceil(Math.sqrt(m))+6);
  const lo = 0, hi = 1;
  const counts = new Int32Array(bins);
  const bw = (hi-lo)/bins;
  let maxCount = 0;
  for(let i=0;i<m;i++){
    let b = Math.floor((vals[i]-lo)/bw);
    if (b<0) b=0; if (b>=bins) b=bins-1;
    counts[b]++;
    if (counts[b]>maxCount) maxCount = counts[b];
  }

  // axes
  hctx.strokeStyle = "#ccc";
  hctx.lineWidth = 1;
  hctx.beginPath();
  // x-axis (values of f)
  hctx.moveTo(L, ch-B);
  hctx.lineTo(cw-R, ch-B);
  // y-axis (counts)
  hctx.moveTo(L, ch-B);
  hctx.lineTo(L, T);
  hctx.stroke();

  // bars (vertical)
  for(let b=0;b<bins;b++){
    const x0 = L + b*(W/bins);
    const barW = (W/bins)*0.9;
    const h = (counts[b]/maxCount)*H;
    const y0 = ch - B - h;
    hctx.fillStyle = "#cfd8ff";
    hctx.fillRect(x0 + (W/bins-barW)/2, y0, barW, h);
  }

  // red dashed line at p (true value)
  const xp = L + (p - lo)/(hi - lo)*W;
  hctx.strokeStyle = "#e74c3c";
  hctx.setLineDash([6,6]);
  hctx.beginPath();
  hctx.moveTo(xp, ch-B);
  hctx.lineTo(xp, T);
  hctx.stroke();
  hctx.setLineDash([]);

  // labels
  hctx.fillStyle = "#333";
  hctx.font = "12px Arial";
  hctx.fillText(`Distribution of f(k) at k=${k}`, L + 10, T + 12);
  hctx.fillText("f(n)", L + W/2 - 10, ch - 10);
  hctx.save();
  hctx.translate(12, T + H/2);
  hctx.rotate(-Math.PI/2);
  hctx.fillText("count", 0, 0);
  hctx.restore();
}


    function updateStats(k){
      let s=0, s2=0; for (let i=0;i<m;i++){ const v = F[i*n + (k-1)]; s+=v; s2+=v*v; }
      const mean = s/m; const var_ = s2/m - mean*mean; const sd = Math.sqrt(Math.max(0,var_));
      const esd = Math.sqrt(p*(1-p)/k);
      stats.textContent = `p=${p.toFixed(3)}  |  mean(f(k))≈${mean.toFixed(4)}  |  sd≈${sd.toFixed(4)}  |  expected sd≈${esd.toFixed(4)}`;
    }

    runBtn.addEventListener('click', simulate);
    kEl.addEventListener('change', function(){ if (!F) return; const k = clamp(parseInt(kEl.value)||1, 1, n); kEl.value=k; draw(); updateStats(k); });

    // First run
    simulate();
  </script>
</body>
</html>
