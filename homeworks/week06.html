<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Random-Walk Security Simulator</title>
<style>
  :root { --fg:#111; --muted:#666; --bg:#fff; --accent:#2266ff; }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
  .wrap{max-width:960px;margin:24px auto;padding:0 16px}
  h1{font-size:18px;margin:8px 0 16px}
  .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:8px;margin-bottom:12px}
  .controls label{display:flex;flex-direction:column;gap:4px;border:1px solid #e5e7eb;border-radius:10px;padding:8px}
  .controls input{padding:6px 8px;border:1px solid #e5e7eb;border-radius:8px}
  button{padding:10px 14px;border-radius:10px;border:1px solid #e5e7eb;background:#f8fafc;cursor:pointer}
  button:hover{background:#eef2ff}
  .row{display:grid;grid-template-columns:1fr;gap:14px}
  .card{border:1px solid #e5e7eb;border-radius:12px;padding:12px}
  .meta{color:var(--muted);font-size:12px}
  canvas{width:100%;height:360px;border-radius:8px;background:#fff;display:block}
  table{border-collapse:collapse;width:100%;font-size:12px}
  th,td{border:1px solid #e5e7eb;padding:6px 8px;text-align:right}
  th:first-child,td:first-child{text-align:center}
  .footer{margin-top:18px;color:var(--muted);font-size:12px}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Random-Walk Security Simulator</h1>
    <div class="controls">
      <label>Weeks (n)
        <input id="n" type="number" min="1" value="52" />
      </label>
      <label>Attackers per week (m)
        <input id="m" type="number" min="0" value="5" />
      </label>
      <label>Attacker breach prob (p)
        <input id="p" type="number" min="0" max="1" step="0.001" value="0.1" />
      </label>
      <label>Trajectories (T)
        <input id="T" type="number" min="10" step="10" value="20000" />
      </label>
      <label>Show sample paths
        <input id="k" type="number" min="1" value="8" />
      </label>
      <div style="display:flex;align-items:end;gap:8px">
        <button id="run">Run simulation</button>
      </div>
    </div>

    <div class="meta" id="stats">—</div>

    <div class="row">
      <div class="card">
        <div class="meta">Sample trajectories (cumulative score over weeks)</div>
        <canvas id="traj"></canvas>
      </div>
      <div class="card">
        <div class="meta">Final-score histogram (bars) vs Binomial expectation (dots/line)</div>
        <canvas id="hist"></canvas>
      </div>
      <div class="card">
        <div class="meta">Central counts (around the mean)</div>
        <div id="table"></div>
      </div>
    </div>

    <div class="footer">
      Model: each week is secure with probability <code>q=(1-p)^m</code>. Score +1 if secure, −1 if breached. Final score <code>S=2X−n</code> with <code>X∼Binomial(n,q)</code>. Total-variation distance compares empirical vs theoretical distributions.
    </div>
  </div>

<script>
function pow(a,b){ return Math.pow(a,b); }
function rand(){ return Math.random(); }

function binomialPMFRow(n,q){
  const pmf = new Array(n+1).fill(0);
  const r = q/(1-q);
  let p0 = pow(1-q, n);
  pmf[0] = p0;
  for (let k=0;k<n;k++){
    p0 = p0 * ((n-k)/(k+1)) * r;
    pmf[k+1] = p0;
  }
  return pmf;
}

function totalVariation(p, q){
  let s=0; for(let i=0;i<p.length;i++) s += Math.abs(p[i]-q[i]);
  return 0.5*s;
}

function simulate(n,m,p,T){
  const q = pow(1-p, m);
  const scores = new Int16Array(T);
  const paths = [];
  const k = Math.min(Number(document.getElementById('k').value||8), T);
  const sampleIdx = new Set();
  while(sampleIdx.size < k){ sampleIdx.add(Math.floor(rand()*T)); }
  const want = new Set(sampleIdx);

  for(let t=0;t<T;t++){
    let s=0;
    let path = want.has(t) ? new Int16Array(n) : null;
    for(let i=0;i<n;i++){
      const secure = rand() < q;
      s += secure ? 1 : -1;
      if(path) path[i] = s;
    }
    scores[t]=s;
    if(path) paths.push(path);
  }
  return {q, scores, paths};
}

function histogramScores(scores, n){
  const L = n+1;
  const counts = new Array(L).fill(0);
  for(const s of scores){
    const i = (s + n)/2;
    if (i>=0 && i<L) counts[i]++;
  }
  return {counts, scoresAxis: Array.from({length:L}, (_,i)=> -n + 2*i)};
}

function getCtx(id){
  const c = document.getElementById(id);
  const ratio = window.devicePixelRatio || 1;
  const w = c.clientWidth, h = c.clientHeight;
  if(c.width !== Math.floor(w*ratio) || c.height !== Math.floor(h*ratio)){
    c.width = Math.floor(w*ratio); c.height = Math.floor(h*ratio);
  }
  const ctx = c.getContext('2d');
  ctx.setTransform(ratio,0,0,ratio,0,0);
  ctx.clearRect(0,0,w,h);
  return {ctx, w, h};
}

function drawAxes(ctx,w,h,pad=28){
  ctx.strokeStyle = '#d1d5db';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(pad, h-pad); ctx.lineTo(w-pad, h-pad);
  ctx.moveTo(pad, pad);   ctx.lineTo(pad, h-pad);
  ctx.stroke();
  return {x0:pad,y0:h-pad, x1:w-pad, y1:pad};
}

function mapLin(x, a,b, A,B){ return A + (x-a)*(B-A)/(b-a); }

function plotTrajectories(paths, n){
  const {ctx,w,h} = getCtx('traj');
  const ax = drawAxes(ctx,w,h);
  let ymin=0, ymax=0;
  for(const path of paths){
    for(const s of path){ if(s<ymin) ymin=s; if(s>ymax) ymax=s; }
  }
  if(ymax===ymin){ ymin-=1; ymax+=1; }
  ctx.lineWidth = 1.25;
  for(const path of paths){
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const x = mapLin(i+1, 1,n, ax.x0, ax.x1);
      const y = mapLin(path[i], ymin,ymax, ax.y0, ax.y1);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.strokeStyle = '#555';
    ctx.stroke();
  }
}

function plotHistogramVsTheory(hist, pmf, T, n){
  const {ctx,w,h} = getCtx('hist');
  const ax = drawAxes(ctx,w,h);
  const xs = hist.scoresAxis;
  const counts = hist.counts;
  const expected = pmf.map((pk)=> pk*T);

  const ymax = Math.max(...counts, ...expected);
  const barW = (ax.x1-ax.x0) / xs.length * 0.9;

  ctx.fillStyle = '#ddd';
  for(let i=0;i<xs.length;i++){
    const x = mapLin(i,0,xs.length, ax.x0, ax.x1) + 1;
    const y = mapLin(counts[i], 0,ymax, ax.y0, ax.y1);
    const y0 = ax.y0;
    ctx.fillRect(x, y, barW, y0 - y);
  }

  ctx.strokeStyle = '#333'; ctx.lineWidth=1.2; ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const x = mapLin(i,0,xs.length, ax.x0, ax.x1) + barW/2;
    const y = mapLin(expected[i], 0,ymax, ax.y0, ax.y1);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  for(let i=0;i<xs.length;i++){
    const x = mapLin(i,0,xs.length, ax.x0, ax.x1) + barW/2;
    const y = mapLin(expected[i], 0,ymax, ax.y0, ax.y1);
    ctx.beginPath(); ctx.arc(x,y,2.5,0,Math.PI*2); ctx.fillStyle='#111'; ctx.fill();
  }
}

function renderCentralTable(container, xs, counts, expected, meanS, stdS){
  const lo = Math.floor(meanS - 2*stdS);
  const hi = Math.ceil(meanS + 2*stdS);
  let rows = [];
  for(let i=0;i<xs.length;i++){
    const s = xs[i];
    if(s>=lo && s<=hi){ rows.push({S:s, Emp:counts[i], Theo:expected[i]}); }
  }
  const html = `
    <table>
      <thead><tr><th>S</th><th>Empirical</th><th>Binomial exp.</th></tr></thead>
      <tbody>
        ${rows.map(r=>`<tr><td>${r.S}</td><td>${r.Emp}</td><td>${r.Theo.toFixed(1)}</td></tr>`).join('')}
      </tbody>
    </table>`;
  container.innerHTML = html;
}

function run(){
  const n = Number(document.getElementById('n').value || 52);
  const m = Number(document.getElementById('m').value || 5);
  const p = Number(document.getElementById('p').value || 0.1);
  const T = Number(document.getElementById('T').value || 20000);

  if(!(p>=0 && p<=1)){ alert('p must be in [0,1]'); return; }

  const {q, scores, paths} = simulate(n,m,p,T);
  const hist = histogramScores(scores, n);
  const pmfK = binomialPMFRow(n, q);
  const expectedCounts = pmfK.map(pk => pk*T);

  const meanS = n*(2*q - 1);
  const varS  = 4*n*q*(1-q);
  const stdS  = Math.sqrt(varS);

  const empP = hist.counts.map(c=>c/T);
  const tv = totalVariation(empP, pmfK);

  plotTrajectories(paths, n);
  plotHistogramVsTheory(hist, pmfK, T, n);
  renderCentralTable(document.getElementById('table'), hist.scoresAxis, hist.counts, expectedCounts, meanS, stdS);

  document.getElementById('stats').textContent = `q=(1-p)^m = ${(q).toFixed(4)}  •  E[S]=${meanS.toFixed(2)}  •  SD[S]=${stdS.toFixed(2)}  •  TV distance=${tv.toFixed(4)}  •  T=${T}`;
}

document.getElementById('run').addEventListener('click', run);
run();
</script>

  <section id="hmwk-2">
  <h2>HMWK 2</h2>
    
  <h3>1) Formal equivalence of the models</h3>
  <p>Let there be <em>m</em> independent attackers, each breaching in a given week with probability <em>p</em>. The probability the server is breached by at least one attacker in a week is</p>
  <div class="math">$$ q = 1 - (1-p)^m, \qquad \text{secure with prob } 1-q = (1-p)^m. $$</div>
  <p>Define weekly steps $$Y_t \in \{+1,-1\}$$ with $$Y_t=+1$$ if secure and $$Y_t=-1$$ if breached. Then</p>
  <div class="math">$$ \mathbb P(Y_t=+1)=1-q,\quad \mathbb P(Y_t=-1)=q. $$</div>
  <p>The cumulative score after <em>n</em> weeks is a (biased) simple random walk</p>
  <div class="math">$$ S_n = \sum_{t=1}^n Y_t, \qquad S_n = (n-B_n) - B_n = n - 2B_n, $$</div>
  <p>where $$B_n \sim \mathrm{Bin}(n,q)$$ is the number of breached weeks.</p>

  <h3>2) LLN/CLT link & online estimators</h3>
  <p>By the LLN for Bernoulli variables, $$B_n/n \to q$$ almost surely, so</p>
  <div class="math">$$ \frac{S_n}{n} = 1 - 2\,\frac{B_n}{n} \;\xrightarrow{\;\text{a.s.}\;}\; 1-2q. $$</div>
  <p>Single-step moments: $$\mathbb E[Y]=1-2q,\quad \operatorname{Var}(Y)=4q(1-q).$$ Hence $$\mathbb E[S_n]=n(1-2q),\ \operatorname{Var}(S_n)=4n\,q(1-q).$$</p>
  <p>The <em>online</em> updates from earlier apply directly to $$Y_t$$ (or to breach indicators $$X_t=\tfrac{1-Y_t}{2}\in\{0,1\}$$): they give $$\mathcal O(1)$$, numerically stable running estimates of the mean/variance and thus of $$q$$ via $$\hat q=\tfrac{1-\hat m}{2}$$.</p>

  <h3>3) Binomial distribution & Pascal’s triangle</h3>
  <p>Reaching $$S_n=s$$ means $$b=(n-s)/2$$ breaches (same parity). The number of length-$$n$$ trajectories with exactly $$b$$ breaches is</p>
  <div class="math">$$ \#\{\text{paths to score } s\} = \binom{n}{b},\qquad b=\frac{n-s}{2}. $$</div>
  <p>These are precisely the entries of <strong>Pascal’s triangle</strong>. The weighting follows the <strong>binomial expansion</strong>:</p>
  <div class="math">$$ ((1-q)+q)^n = \sum_{b=0}^n \binom{n}{b} (1-q)^{n-b} q^b. $$</div>
  <p>For large $$n$$, by the CLT, $$S_n$$ is approximately normal with the mean and variance above.</p>

  <h3>4) Random-walk viewpoint</h3>
  <p>This is a biased simple random walk with up-step probability $$1-q$$. The special case $$q=\tfrac12$$ is symmetric (zero drift); mapping from $$B_n$$ to $$S_n$$ scales variance by the step size (here 2).</p>

  <h3>5) Fibonacci and related combinatorics</h3>
  <ul>
    <li><em>Pascal–Fibonacci.</em> Sums along shallow diagonals of Pascal’s triangle yield Fibonacci numbers:
      $$F_k=\sum_j \binom{k-j-1}{j}.$$</li>
    <li><em>No consecutive breaches.</em> If two successive −1 steps are forbidden, the number of admissible sequences of length $$n$$ equals $$F_{n+2}$$ (compositions into 1’s and 2’s).</li>
    <li><em>(Optional) Catalan.</em> Constraining paths to never dip below a baseline leads to Catalan counts, another classic link between random walks and combinatorics.</li>
  </ul>

  <h3>6) Beyond IID & large-system limits</h3>
  <ul>
    <li><em>Many attackers, small p.</em> With $$m$$ large and $$p$$ small, letting $$\lambda=mp$$ gives $$q=1-(1-p)^m\approx 1-e^{-\lambda}\approx \lambda$$ for small $$\lambda$$; per week it’s still Bernoulli$$(q)$$ and over $$n$$ weeks Bin$$(n,q)$$.</li>
    <li><em>Heterogeneous weeks.</em> If $$q_t$$ varies (changing $$m_t$$ or $$p_t$$), the breach count is <em>Poisson-binomial</em>. The random-walk view still holds with time-varying bias; online estimators still work.</li>
  </ul>

  <h3>7) Tie-back to online statistics</h3>
  <p>The streaming mean/variance (Welford) from the previous work gives real-time LLN demonstrations: for the Bernoulli indicators it tracks the breach rate $$q$$; for the random walk it tracks drift and variability of $$S_n$$,  directly connecting HMWK 1 to the earlier location/dispersion and online computation content.</p>
</section>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
